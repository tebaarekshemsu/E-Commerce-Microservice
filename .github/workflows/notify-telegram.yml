name: Telegram Notify

on:
  push:
    branches: [main]
  workflow_run:
    workflows: ["CI"]
    types: [completed]

jobs:
  notify:
    # run for pushes OR for completed workflow runs (success or failure)
    if: ${{ github.event_name == 'push' || github.event_name == 'workflow_run' }}
    runs-on: ubuntu-latest
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      TOPIC_ID: 154
      EVENT_NAME: ${{ github.event_name }}
      GITHUB_ACTOR: ${{ github.actor }}
      GITHUB_REPO: ${{ github.repository }}
      # push fields (may be empty for workflow_run events)
      PUSH_COMMIT_SHA: ${{ github.sha }}
      PUSH_COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
      # workflow_run fields (may be empty for push events)
      WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
      WORKFLOW_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
      WORKFLOW_URL: ${{ github.event.workflow_run.html_url }}
      WORKFLOW_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
    steps:
      - name: Notify Telegram (push or failed workflow)
        shell: bash
        run: |
          # Escape function for Telegram MarkdownV2
          escape_md_v2() {
            perl -C -pe 's/([_\*\[\]\(\)~`>#\+\-\=\|\{\}\.\!\\])/\\$1/g' <<< "$1"
          }

          if [ "$EVENT_NAME" = "push" ]; then
            TITLE="ðŸš€ New Push to main"
            AUTHOR_ESC=$(escape_md_v2 "${GITHUB_ACTOR}")
            SHA_ESC=$(escape_md_v2 "${PUSH_COMMIT_SHA}")
            COMMIT_MSG_ESC=$(escape_md_v2 "${PUSH_COMMIT_MESSAGE}")
            REPO_ESC=$(escape_md_v2 "${GITHUB_REPO}")
            lines=()
            lines+=("*${TITLE}*")
            lines+=("ðŸ‘¤ Author: \`${AUTHOR_ESC}\`")
            lines+=("ðŸ†” Commit: \`${SHA_ESC}\`")
            lines+=("ðŸ“ Message: _${COMMIT_MSG_ESC}_")
            lines+=("ðŸ”— Repo: ${REPO_ESC}")
            MSG=$(printf '%s\n' "${lines[@]}")
          else
            if [ "$WORKFLOW_CONCLUSION" = "success" ]; then
              TITLE="âœ… Workflow Succeeded"
            else
              TITLE="âŒ Workflow Failed"
            fi
            WF_NAME_ESC=$(escape_md_v2 "${WORKFLOW_NAME}")
            CONCL_ESC=$(escape_md_v2 "${WORKFLOW_CONCLUSION}")
            WF_URL_ESC=$(escape_md_v2 "${WORKFLOW_URL}")
            HEAD_SHA_ESC=$(escape_md_v2 "${WORKFLOW_HEAD_SHA}")
            ACTOR_ESC=$(escape_md_v2 "${GITHUB_ACTOR}")
            lines=()
            lines+=("*${TITLE}*")
            lines+=("âš™ï¸ Workflow: *${WF_NAME_ESC}*")
            lines+=("ðŸ‘¤ Triggered by: \`${ACTOR_ESC}\`")
            lines+=("ðŸ†” Head SHA: \`${HEAD_SHA_ESC}\`")
            lines+=("ðŸš¨ Conclusion: *${CONCL_ESC}*")
            lines+=("ðŸ”— Run: ${WF_URL_ESC}")
            MSG=$(printf '%s\n' "${lines[@]}")
          fi

          # Debugging: print key info (secrets are masked by GitHub Actions)
          echo "EVENT_NAME=${EVENT_NAME}"
          echo "WORKFLOW_CONCLUSION=${WORKFLOW_CONCLUSION}"
          echo "GITHUB_ACTOR=${GITHUB_ACTOR}"
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID is not set. Cannot send notification."
            # print the assembled MSG for debugging (do NOT print secrets)
            echo "===== MESSAGE BEGIN ====="
            echo "$MSG"
            echo "===== MESSAGE END ====="
            exit 1
          fi

          # Send message to Telegram (use MarkdownV2). Capture response and HTTP code for debugging.
          response=$(curl -sS -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d chat_id="${TELEGRAM_CHAT_ID}" \
            -d parse_mode="MarkdownV2" \
            -d message_thread_id="${TOPIC_ID}" \
            --data-urlencode text="$MSG" ) || true

          echo "Telegram API response:" 
          echo "$response"

          # Fail the step if HTTP code indicates error (non-2xx)
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')
          if [[ "$http_code" != 2* ]]; then
            # If it's a Markdown parse error, retry without parse_mode (plain text)
            if [[ "$http_code" == "400" ]] || echo "$body" | grep -qi "can't parse entities"; then
              echo "Detected parse error from Telegram, retrying with HTML fallback..."
              # Build an HTML-escaped payload and wrap in <pre> to preserve formatting
              fallback_payload=$(printf '%s\n' "${lines[@]}" | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g')
              fallback_content="<pre>${fallback_payload}</pre>"

              fallback_response=$(curl -sS -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                -d chat_id="${TELEGRAM_CHAT_ID}" \
                -d parse_mode="HTML" \
                -d message_thread_id="${TOPIC_ID}" \
                --data-urlencode text="$fallback_content" ) || true

              echo "Fallback response:" 
              echo "$fallback_response"

              http_code2=$(echo "$fallback_response" | tail -n1)
              body2=$(echo "$fallback_response" | sed '$d')
              if [[ "$http_code2" != 2* ]]; then
                echo "ERROR: Fallback also failed with HTTP code $http_code2"
                echo "Response body: $body2"
                exit 1
              else
                echo "Fallback send succeeded (HTTP $http_code2)."
              fi
            else
              echo "ERROR: Telegram API returned HTTP code $http_code"
              echo "Response body: $body"
              exit 1
            fi
          fi
